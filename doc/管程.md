
### 管程，并发编程的万能钥匙

1.操作系统：信号量能解决所有的并发问题
2.管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号实现管程。但是管程更容易使用，所以Java选择了管程。

管程，对应的英文是Monitor，Java领域都喜欢防御为'监视器'，操作系统领域一般都翻译成'管程'

所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。翻译为Java领域的语言，
就是管理类的成员变量和成员方法，让这个类是线程安全的。


Hasen模型，Hoare模型和MESA模型，现在广泛应用的是MESA模型，Java管程的实现参考的也是MESA模型

                互斥和同步

A:管程如何解决互斥问题？

管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。

    monitorX{
        //共享变量：队列
        var queue;
        //操作：入队
        func enq();
        //操作：出队
        func deq();
    }

管程X将共享变量queue这个队列和相关的操作入队enq(),出队deq（),都封装起来了;
线程A和线程B如果想访问共享变量queue，只能通过调用管程提供的enq(),deq()方法来实现;
enq(),deq()保证互斥性，只允许一个线程进入管程。

管程模型和面向对象高度契合的，估计这也是Java选择管程的原因吧。



B:管程如何解决线程间的同步问题？

在管程模型里，共享变量和对共享变量的操作是被封装起来的。

条件变量和等待队列的概念（类似就医流程）


MESA管程的编程范式：
wait()的正确姿势
    while(条件不满足){
        wait();
    }


Hasen模型，Hoare模型和MESA模型的一个核心区别，当条件满足后，如何通知相关线程。
    管程要求同一时刻只允许一个线程执行，那当线程T2的操作使线程T1等待的条件满足时，T1和T2究竟谁可以执行呢？

1.Hasen模型，要求notify（）放在代码的最后，这样T2通知完T1后，T2就结束了，然后T1再执行

2.Hoare模型，T2通知完T1后，T2阻塞，T1马上执行；等T1执行完，再唤醒T2,也能保证同一时刻只有一个线程执行。
    相比Hasen模型，T2多了一次阻塞唤醒操作。

3.MESA管程里面，T2通知完T1后，T2还是会接着执行，T1并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。
    这样做的好处是notify（）代码不用放到代码的最后，T2也没有多余的阻塞唤醒操作。但是也有个副作用，就是当T1再次
    执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要循环方式检验条件变量。


notify()何时使用？（三个条件都满足）

1.所有等待线程拥有相同的等待条件。
2.所有等待线程被唤醒后，执行相同的操作。
3.只需要唤醒一个线程。



Java参考了MESA模型，语言内置的管程（synchroinzed）对MESA模型进行了精简。MESA模型中，
条件变量可以有多个，Java语言内置的管程只有一个条件变量。Java SDK并发包实现的管程支持多个条件变量
，不过并发包里的锁，需要开发人员自己进行加锁和解锁。














