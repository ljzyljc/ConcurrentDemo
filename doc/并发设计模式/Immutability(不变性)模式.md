### Immutability模式：如何利用不变性解决并发问题

1.解决并发性问题，其实最简单的方法就是让共享变量只有读操作，而没有写操作。就是解决并发问题的设计模式，

即**不变性（Immutability）模式。所谓的不变性，简单来讲，就是对象一旦被创建，状态就不在发生变化**。换句话说，

就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。


2.快速实现具备不可变性的类
    
    将一个类的所有属性都设置成final的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了。
    
    更严格的做法是这个类本身也是final的，不允许继承，这样子类不能重写父类的方法。也失去了修改不可变性的可能性。
    
3.String和Long,Integer,Double等基础类型的包装类都具备不可变性。**这些对象的线程安全性都是靠不可变性来保证的**。

他们的类和属性都是final的，所有的方法都是只读的。

比如：String中的replace，如果不可变性的类，需要提供类似修改的功能，具体该如何操作？

    **那就是创建一个新的不可变对象**
    
4.利用享元模式避免创建重复对象

    利用享元模式可以减少创建对象的数量，从而减少内存占用。Java语言里面的Long,Integer,Short,Byte等这些基本数据类型的包装类都用到了享元模式。
    
    享元模式的本质其实就是一个**对象池**。
    
    Long这个类并没有照搬享元模式，Long内部维护了一个静态的对象池，仅缓存了[-128,127]之间的数字，这个对象在JVM启动的时候就创建好了，而且这个
    
    对象池一直都不会变化，也就是说它是静态的。这个区间的数字利用率最高。
    
    
    Long valueOf(long l) {
      final int offset = 128;
      // [-128,127] 直接的数字做了缓存
      if (l >= -128 && l <= 127) { 
        return LongCache
          .cache[(int)l + offset];
      }
      return new Long(l);
    }
    // 缓存，等价于对象池
    // 仅缓存 [-128,127] 直接的数字
    static class LongCache {
      static final Long cache[] 
        = new Long[-(-128) + 127 + 1];
    
      static {
        for(int i=0; i<cache.length; i++)
          cache[i] = new Long(i-128);
      }
    }


5.Integer和String类型的对象不适合做锁，其实基本上所有的基础类型的包装类都不合适做锁，因为他们内部都用到了享元模式，

这会导致看上去私有的锁，其实是共有的。如下代码：

    class A {
      Long al=Long.valueOf(1);
      public void setAX(){
        synchronized (al) {
          // 省略代码无数
        }
      }
    }
    class B {
      Long bl=Long.valueOf(1);
      public void setBY(){
        synchronized (bl) {
          // 省略代码无数
        }
      }
    }


6.使用Immutability模式的注意事项

    1.对象的所有属性都是final的，并不能保证不可变性
    
    2.不可变对象也需要正确的发布
    
  使用Immutablility模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。
  
  
  不可变性虽然是线程安全的，但是并不意味着引用这些不可变性的对象就是线程安全的。
  
  
7.其实还有一种更简单的不变性对象，那就是**无状态**。无状态对象内部没有属性，只有方法。除了无状态的对象，你可能
    
   还听说过无状态的服务，无状态的协议等待。无状态有很多好处，最核心的一点就是性能。在多线程领域，无状态对象没有线程安全问题，
   
   无需同步处理，自然性能就很好；在分布式领域，无状态意味着可以无限地水平扩展，所以分布式领域里面的性能瓶颈一定不是出现在无状态的服务节点上。   
 
























