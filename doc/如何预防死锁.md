
### 如何预防死锁

死锁的发生条件（必须全部满足）
1.互斥，共享资源X和Y只能被一个线程占用；
2.占用且等待，线程T1已经取得共享资源X,在等待共享资源Y的时候，不释放共享资源X;
3.不可抢占，其它线程不能强行抢占线程T1占用的资源；
4.循环等待，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。

只要破坏其中一个，就可以避免死锁的发生。

1.破坏占用且等待条件：一次性申请所有资源
2.破坏不可抢占条件：使用Lock
3.破坏循环等待条件：对资源进行排序，然后按序申请资源。



wait(),notify(),notifyAll()这三个方法能被调用的前提的已经获取了相应的互斥锁。（IllegalMonitorStateException异常）

while(条件不满足){
    wait()
}

尽量使用notifyAll()

wait与sleep的区别：
    1.wait会释放所有锁而sleep不会释放锁资源
    2.wait只能在同步方法和同步块中使用，而sleep任何地方都可以
    3.sleep是Thread的方法，而wait是Object类的方法


竞态条件：程序的执行结果依赖线程执行的顺序

活锁：有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况。
    解决方案：谦让时，尝试等待一个随机的时间就可以了

饥饿：指的是线程因为无法访问所需资源而无法执行下去的情况。
    解决方案：1.保证资源充足
             2.公平的分配资源
             3.避免持有锁的线程长时间执行


性能问题：阿姆达尔法则

指标：1.吞吐量
     2.延迟
     3.并发量


存在并发问题的程序：   存在竞态条件，contains方法不是线程安全的
    void addIfNotExist(Vector v,Object o){
        if(!v.contains(o){
            v.add(0)
        }
    }

